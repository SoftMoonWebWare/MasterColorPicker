//  character encoding: UTF-8 UNIX   tab-spacing: 2 ¡important!   word-wrap: no   standard-line-length: 160

// Picker.js  Beta-4.2.3   December 19, 2023  by SoftMoon-WebWare.
/*   written by and Copyright © 2011, 2012, 2013, 2014, 2015, 2019, 2020, 2022, 2023 Joe Golembieski, SoftMoon-WebWare

		This program is licensed under the SoftMoon Humane Use License ONLY to “humane entities” that qualify under the terms of said license.
		For qualified “humane entities”, this program is free software:
		you can use it, redistribute it, and/or modify it
		under the terms of the GNU General Public License as published by
		the Free Software Foundation, either version 3 of the License, or
		(at your option) any later version, with the following additional requirements
		ADDED BY THE ORIGINAL SOFTWARE CREATOR AND LICENSOR that supersede any possible GNU license definitions:
		This original copyright and licensing information and requirements must remain intact at the top of the source-code.

		This program is distributed in the hope that it will be useful,
		but WITHOUT ANY WARRANTY; without even the implied warranty of
		MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
		GNU General Public License for more details.

		You should have received a copy of:
		 • the SoftMoon Humane Use License
		and
		 • the GNU General Public License
		along with this program.  If not, see:
			https://softmoon-webware.com/humane-use-license/
			https://www.gnu.org/licenses/
		*/

// requires SoftMoon-WebWare’s +++.js package.
// requires SoftMoon-WebWare’s UniDOM-2020 package.


/*   The SoftMoon “namespace” is usually a constant defined in a “pinnicle” file somewhere else
const SoftMoon=Object.defineProperty({}, "WebWare", {value:{}, enumerable:true});
*/

								 // ¡!YO!¡ \\
								//  ↓    ↓  \\
//  ********  be SURE to READ the comments on applied classNames just below the Picker constructor function  **********

'use strict';

	// ↓ for “simulating” a double-click, triple-click, etc.,
	// ↓ when a buttonpress event is generated by the enter-key,
	// ↓ and it is pressed x times in this many milliseconds
SoftMoon.keyPressRepeatTimeoutDelay??=1200;



{  // create a private namespace for the Picker class

//********* Picker constructor ************\\
// the “mainPanel” should •be 1 or •wrap 1 or more
//    “picker” DOM Elements→ className = PickerInstance.classNames.picker,
//    each Element being a separate picker (note also the picker_select option below).
// “opts.picker_select” optional - should be a <select> tag or an Array of <input type='checkbox|radio' />
//    to choose which picker is “active” (using PickerInstance.classNames.activePicker);
//    or null may be passed in and all pickers will be considered “active” when the picker-interface is active.
// “opts.pickFilter” optional - may be a function, an Object with an “onPick” method, or an Array of these to supplement (or replace by returning false)
//    the standard “PickerInstance.pick” function.  The function will be a method of the Picker instance, but the Object.onPick will be a method of the Object.
// “opts.masterDataTarget” optional - may be a DOM Element which will *always* receive the value picked
//    by the Picker, unless picker is activated using  PickerInstance.setActivePickerState(true, dataTarget)
//    and when this dataTarget relinquishes focus, the picker reverts back to using the “masterDataTarget”
// “opts.classNames” optional - may be an Object with properties to replace the implementation level of
//    the standard-default Picker.CLASSNAMES
// “opts.doKeepInterfaceFocus” optional - Boolean ← ¿do interface controls keep focus when the ENTER key is pressed?
//    if not focus is returned to the dataTarget
//    you can also control this value globally through the prototype
// if “registerPanel” is not true, you can register individual “interfaceControls” before registering the “mainPanel”
// (so you can set individual TAB-control and interfaceTarget properties without needing to touch the HTML markup)
// but you must then be sure to register the mainPanel “manually” after registering the specific “interfaceControls”.
SoftMoon.WebWare.Picker=Picker;
function Picker(mainPanel, opts)  {
	if (!new.target)  throw new Error("Picker is a constructor, not a function.");
	if (!UniDOM.isElement(mainPanel))  throw new TypeError("Picker mainPanel must be a DOM Element Node.");

	this.mainPanel=mainPanel;
	this.panels=new UniDOM.ElementArray(false);
	this.pickers=new UniDOM.ElementArray(false);
	this.pickerActiveFlag=false;
	this.interfaceActiveFlag=false;
	this.masterTarget=null;
	var dataTarget=null;
	Object.defineProperty(this, "dataTarget", { enumerable:true,
		get: function()  {
		return (  (dataTarget?.isConnected  &&  dataTarget)
					 || (this.masterTarget?.isConnected  &&  this.masterTarget)  );  },
		set: dT=>dataTarget=dT });
	this.interfaceControl=undefined;
	this.interfaceTarget=undefined;
	Object.defineProperty(this, "currentTarget", { enumerable:true,
		get:function()  {
		return (  (this.interfaceTarget?.isConnected  &&  this.interfaceTarget)
					 || this.dataTarget  );  }});
	Object.defineProperty(this, "currentInterface", { enumerable:true,
		get:function()  {
		return (  (this.interfaceControl?.isConnected  &&  this.interfaceControl)
					 || this.dataTarget  );  }});
	this.registeredTargets=new UniDOM.ElementArray(false);
	this.pickFilters=new Array;
	this.ATTRIBUTE_NAMES=Object.create(Picker.ATTRIBUTE_NAMES);
	this.classNames=Object.create(Picker.CLASSNAMES);

	if (typeof opts === 'object')  {

		if (opts.picker_select)  {
			if ((UniDOM.isElement(opts.picker_select)  &&  opts.picker_select.nodeName==='SELECT')
			||  (opts.picker_select instanceof Array
					&&  opts.picker_select.length
					&&  opts.picker_select.every(e => UniDOM.isElement(e)  &&
																						e.nodeName==='INPUT'  &&
																						(e.type==='checkbox' ||  e.type==='radio'))))  {
				if (opts.picker_select.nodeName==='SELECT')  {
					this.picker_select=UniDOM.addPowerSelect(opts.picker_select);
					for (const opt of this.picker_select.options)  {
						if (opt.value === undefined)  opt.value=opt.text;  }  }
				else  this.picker_select=(new UniDOM.ElementArray).concat(opts.pickerSelect);
				UniDOM.addEventHandler(this.picker_select, 'onchange', () => {
					this.choosePicker(this.classNames.activePicker, null, this.pickerActiveFlag);
					this.choosePicker(this.classNames.activePickerInterface, null, this.interfaceActiveFlag);  });
				this.picker_select.isChosenPicker=function(picker)  {
					return this.getSelected(true).some(e => picker.id===e.value.replace( /\s/g , ""));  }  }

			else  throw new TypeError("picker_select must be a DOM <select> Element Node or an Array of DOM <input type='checkbox|radio'> Element Nodes");  }

		if (!(opts.pickFilters instanceof Array))  opts.pickFilters=[opts.pickFilters];
		for (let i=0; i<opts.pickFilters.length; i++)  {
			if (typeof opts.pickFilters[i] === 'function')  this.pickFilters.push(opts.pickFilters[i]);
			else if (opts.pickFilters[i])  throw new TypeError("Picker “opts.pickFilters["+i+"]” must be a function");  }

		if (opts.masterDataTarget)  {
			this.masterTarget=opts.masterDataTarget;  }

		if (opts.classNames)  { const errTxt="Picker “classNames” Object is invalid.";
			if (typeof opts.classNames !== 'object')  throw new TypeError(errTxt);
			for (const p in Picker.CLASSNAMES)  { if (opts.classNames[p] !== undefined)  {
				if (typeof opts.classNames[p] !== 'string'
				&&  (p!=='picker'  ||  !(opts.classNames[p] instanceof RegExp)))
					throw new TypeError(errTxt+" ClassNames must be strings; except “picker” may be a Regular Expression.");
				this.classNames[p]=opts.classNames[p];  }  }  }

		if ('doKeepInterfaceFocus' in opts)  this.doKeepInterfaceFocus=opts.doKeepInterfaceFocus;  }

//  aria_popUp should be either:
//    • the mainPanel if it is the only panel
//    • the parent-container Element of all the panels, if there is more than one panel.
//  In case a panel must be outside this container, use “aria-owns” on this aria_popUp container to point to the free-range panel.
//  This will typically be the case when you have multiple targets associated with a Picker widget
//   that specify “pickerContainers” (see “setActivePickerState()”), & multiple panels in said Picker widget;
//   the Picker will move the “mainPanel” into these individual containers, while the other panels will remain where they were,
//   thus allowing the “mainPanel” to move and be displayed next-to or near the target input.
//  If you don’t want ARIA-support added to your “target” (that Object which recieves the data “picked” by the user)
//   set aria_popUp ==false
	this.aria_popUp= (opts  &&  "aria_popUp" in opts) ? opts.aria_popUp : mainPanel;

	if (opts?.registerPanel!==false)  this.registerInterfacePanel(mainPanel, opts?.panelOpts);  }



								 // ¡!YO!¡ \\
								//  ↓    ↓  \\
//these are default class names.  Changing them changes the values for all future Pickers created.
//Pass in opts.classNames when creating a Picker for instance-based class names; or modify  yourInstance.classNames

//¡old & irrelevant for modern browsers →!  Content within a pickerPanel including the Pickers themselves should not use scroll-bars;
//  the mainPanel or other panels should scroll if necessary.
//This is required to keep focus on the targetElement when the scroll-bars are clicked-on without blocking a click on the Picker.
Picker.CLASSNAMES={
	picker: 'picker',/*see ‡NOTE‡ below*/      // ← the className that needs to be applied to all pickers in all panels
	pickerPanel: 'pickerPanel',                // ← applied to the mainPanel and any other registered panels
	selectedPicker: 'selectedPicker',          // ← applied to a picker when it is selected
	activePicker: 'activePicker',              // ← applied to:  ((active means the currentTarget input has focus))
																						 //   • a picker when it is selected and active
																						 //   • all panels when a picker is active
	activePickerInterface: 'activePickerInterface',  // ← applied to:
																						 //   • the selected picker(s) when any interfaceControl has focus
																						 //     (an interfaceControl is an element in your picker
																						 //      or one of the panels, that the user modifies and therefore requires
																						 //      “focus” — <input type='(most but not all)' /> <textarea> <select> —
																						 //      to adjust the picker itself and/or its choices;
																						 //      see “registerInterfacePanel” below)
	activeInterfaceTarget: 'activeInterfaceTarget', // ← applied to an interfaceTarget when it has focus
	activeInterface: 'activeInterface',        // ← applied to:
																						 //   • all panels when any one of the interfaceControls has focus
																						 //   • an interfaceControl when it has focus
	activePanel: 'activePickerPanel',          // ← applied to a panel when
																						 //   • it is the top panel and the currentTarget has focus (is active)
																						 //   • it is the top panel and one of its interfaceControls has focus
	topPanel: 'topPickerPanel',                // ← applied to a panel when it is the top panel; see also “panel level” below.
	panelLevel: 'pickerPanelZLevel' };    // ← panelZLevel will be post-fixed with a digital level (1 – ∞, 1 at the bottom)
			// representing a CSS z-index level (like this:  div.pickerPanelZLevel1 {z-index: 1}   ← of course use your own z-index values as needed……and any element, not only <div>
			//																							 div.pickerPanelZLevel2 {z-index: 2}   etc… … …)
			// **when you have more than one panel (mainPanel + others)** clicking on a panel brings it to the top level.
			// These ZLevel classNames are applied automatically to →→ all ←← panels when you:
			//   • pass in a mainPanel with “opts.registerPanel!==false” as you create a new PickerInstance
			//   • register a panel (see:  Picker.prototype.registerInterfacePanel  below)
			//   • click on any registered panel
			// Initially, the mainPanel is at the top, and the sub-panels are arranged last-registered at the bottom.
// ‡NOTE‡ all classNames must be simple strings
//  EXCEPT:  “classNames.picker”  MAY BE ANY VALUE ↓ LEGAL FOR →  UniDOM.has$Class()
//  • a string or a regular expression
//  • a “logic” array of strings, regular expressions, and/or nested “logic” arrays


/* This important property is a flag that controls whether the Picker
 * “adds” the selection picked by the end-user to the data-target “value(s)” (input, textarea, select, etc.)
 * or “replaces” the “value”.  The target may have an HTML attribute "additive" that overrides this flag.
 * <input>s and <textarea>s recognize when the attribute  additive='end'
 * and will add the picked text to the end of the existing text;
 * otherwise they add it where the cursor is placed or was last placed, or selected text is replaced.
 * For examples:
 * <textarea additive>My thoughts about color are many. My favorite color is  and my next favorite is . … … …</textarea>
 * ↑↑↑ Here the “additive” attribute has been included but left empty and the picked-text will be added where the cursor is focused.
 * ↑↑↑ However, if the end-user “selected” (highlighted) a section of text within, it will be replaced.
 * <input type='text' additive='end' value='My favorite color is '>
 * ↑↑↑ here the “additive” attribute specifies the picked-text is always added to the end of the existing value
 * ↑↑↑ regardless of where the cursor is focused or whether text within the value was selected (highlighted) by the end-user.
 * <select additive><option>…1…</option><option>…2…</option><option selected>…?…</option></select>
 * ↑↑↑ here an additional <option></option> will be added to the <select></select>, always at the end of the list of options.
 * ↑↑↑ here the “additive” attribute may not be included, and the “selected option’s value” will be replaced
 */
Picker.prototype.targetIsAdditive=false;


	// ↓ Boolean ← ¿do InterfaceControls (input-type=text for example) keep focus by default when the ENTER key is pressed?  =false → the data/master target is focused instead
	// ↓  the InterfaceControl may have an attribute 'keep-focus' —  ===true when value undefined; or the value is evaluated by Boolean.eval()
Picker.prototype.doKeepInterfaceFocus=false;

// ARIA specs are such that a “picker widget” is “controlled” by a single other element.
// We want our widgets to be able to be controlled by many other elements (such as multiple inputs that use the same picker)
// but we also want to allow our “targets” (that which receives the “picked data”) to be simple JavaScript Objects if desired or required.
// HTML Elements (such as inputs) should be ARIA compliant, but we don’t want to muddy up other target Objects.
// When using an HTML Element, we want to add and remove the ARIA support on-the-fly
// so only one of multiple inputs gets to “control” the “dialog” “popup” at a time.
// If the “aria-expanded” attribute was on the “popup” instead of the “controller” (as would make more semantic sense anyway), this would not be an issue…
Picker.prototype.supportsARIA=true;

/* In previous versions, only QUERTY keyboards were supported, and you could avoid pressing  SHIFT  with  CTRL  ,<  .>
	To support other keyboards, that convenience is now gone.
	Also, now we are forced to accept that some OSs will generate different key values with the CTRL key pressed
	and we will then not be able to tab to other panels with these default values.
	Still stuck in the “not enough mid-level support in events” rut………
	…Would love to use the ← → keys (with CTRL) instead, but the browser uses them.
	You can customize these keys for your keyboard through this prototype or after you create a picker instance
	(see UniDOM, & the function  keyDownOnInterfaceControl  below).
	Note for now, the CTRL key must be pressed for panel-tabbing to work if you customize these keys – it is hardcoded into the function itself.
	These keys defined ↓ below ↓ control tabbing •from the data-target to the picker-select or a panel, or •from one panel to another
*/
Picker.prototype.panelTabKey=new UniDOM.KeySniffer('>', undefined, true, false, false, false, false);
Picker.prototype.panelBacktabKey=new UniDOM.KeySniffer('<', undefined, true, false, false, false, false);
                                                  //   key  shift      ctrl  alt    meta   altGraph  OS

Picker.prototype.setTopPanel=function setTopPanel(panel, rotate)  {
	if (panel===this.panels[this.panels.length-1])  return;
	if (typeof rotate === 'number')  this.panels=this.panels.slice(rotate).concat(this.panels.slice(0, rotate));
	if (panel)  {
		const i=this.panels.indexOf(panel);
		if (i>=0)  this.panels.splice(i, 1);
		this.panels.push(panel);  }  // note that if “panel” was never registered, it will be added to the “panels” array
	for (var i=0; i<this.panels.length; i++)  {
		UniDOM.generateEvent(this.panels[i], 'pickerPanelZLevelChange',
			{bubbles:true}, {Picker: this, newTopPanel: panel, currentLevel: i, rotate: rotate});  }
	const rc=RegExp('\\b(' + RegExp.escape(this.classNames.panelLevel) + '[0-9]+|' + RegExp.escape(this.classNames.topPanel) + '|' + RegExp.escape(this.classNames.activePanel) + ')\\b', 'g');
	for (i=0; i<this.panels.length; i++)  {
		UniDOM.swapOut$Class(this.panels[i], rc, this.classNames.panelLevel+String(i+1));  }
	const tc=[this.classNames.topPanel];
	if (this.pickerActiveFlag  ||  this.interfaceActiveFlag)  tc.push(this.classNames.activePanel);
	UniDOM.addClass(this.panels[i-1], tc);  }



// MSIE9 (and most likely previous versions) fail to trigger an onblur event for the target element under certain
//  circumstances when you click on a scroll-bar within the picker.  {code to handle this has been removed}
Picker.prototype.setActivePickerState=function setActivePickerState(flag, target)  {
// when flag=true, target is:
//                     • an object with a “focus()” method and a “value” property which becomes the “dataTarget”
//                     • when pickerInstance.aria_popUp!=false, target should be an HTML Element
//                     • a flag when ==false → use the current “dataTarget” (or “masterTarget”←that happens automatically)
// when flag=false, target is ignored
// old & irrevant → when flag=false, target is a flag → true=“revert to masterTarget”  false=“retain dataTarget”
	if (!flag  &&  this.interfaceActiveFlag   &&  this.interfaceControl)
		this.setActiveInterfaceState(false, this.interfaceControl);
	const wasActive=this.pickerActiveFlag;
	this.pickerActiveFlag=flag;
	if (flag  &&  target)  this.dataTarget=target;
	else  target=this.dataTarget;
	if (this.aria_popUp)  {
		if (flag)  {
			target.setAttribute('aria-haspopup', this.aria_popUp.getAttribute('role'));
			target.setAttribute('aria-controls', this.aria_popUp.id);
			target.setAttribute('aria-expanded', 'true');  }
		else  {
			target.removeAttribute('aria-haspopup');
			target.removeAttribute('aria-controls');
			target.removeAttribute('aria-expanded');  }  }
	if (flag  &&  target?.pickerContainer)  {
		if (typeof target.pickerContainer==='string')
			document.getElementById(target.pickerContainer).appendChild(this.mainPanel);
		else  target.pickerContainer.appendChild(this.mainPanel);  }
	this.choosePicker(this.classNames.activePicker, null, flag);
	this.setTopPanel();
/**/
	for (const panel of this.panels)  {
		UniDOM.useClass(panel, this.classNames.activePicker, flag);
		UniDOM.generateEvent(panel, 'pickerStateChange',
			{bubbles:true}, {pickerStateFlag: flag,  oldState: wasActive,  Picker: this,  currentDataTarget: target});  }
/* note that this coding-format below sets all classNames first, then generates events.
 * This format fails (¿perhaps because of the above note?), but it seems to be a bug within UniDOM … or maybe in the SpiderMonkey JavaScript engine?
 * The pickerStateChange event registered (in another file) calls UniDOM.disable, but that function receives a “classname” argument of "pickerStateChange"
 * when there should be NO ARGUMENT passed at all! (See MasterColorPicker.js line numbers ≈ 5374-5381 (shuts down “picker-options” when no picker is active)) * /
	this.panels.useClass(this.classNames.activePicker, flag);
	this.panels.generateEvent('pickerStateChange',
			{bubbles:true}, {pickerStateFlag: flag,  oldState: wasActive,  Picker: this,  currentDataTarget: target});
/**/
	if (this.onPickerStateChange)  this.onPickerStateChange(flag, wasActive, target);  }



Picker.prototype.setActiveInterfaceState=function setActiveInterfaceState(flag, target, isInterfaceTarget)  {
	if (flag  &&  !this.pickerActiveFlag   &&  this.masterTarget)
		this.setActivePickerState(true, this.masterTarget);
	if (flag  &&  this.interfaceActiveFlag  &&  target===this.interfaceControl)  return false;  //avoid wasting time
	UniDOM.useClass(target, this.classNames.activeInterface, flag);
	UniDOM.useClass(target, this.classNames.activeInterfaceTarget, flag && isInterfaceTarget);
	if (!flag  &&  target  &&  this.interfaceControl!==target)  return false;  //avoid overlapping events when calling onfocus of one causes onblur of a previous to follow
	const wasActive=this.interfaceActiveFlag;
	this.interfaceActiveFlag=flag;
	this.choosePicker(this.classNames.activePickerInterface, null, flag);
	this.interfaceControl= flag ? target : undefined;
	this.interfaceTarget= (flag  &&  isInterfaceTarget) ? target : undefined;
	for (const panel of this.panels)  {
		UniDOM.useClass(panel, this.classNames.activeInterface, flag);
		UniDOM.generateEvent(panel, 'interfaceStateChange',
			{bubbles:true},  {interfaceStateFlag: flag,  oldState: wasActive,  Picker: this,  currentDataTarget: target});	}
	if (this.onInterfaceStateChange)  this.onInterfaceStateChange(flag, wasActive, target);  }



Picker.prototype.choosePicker=function choosePicker(activeClasses, pickerName, flag)  {
	var pickers=new Array;
	for (const panel of this.panels)  {
		let temp=UniDOM.getElementsBy$Class(panel, this.classNames.picker);
		if (temp)  pickers=pickers.concat(temp);  }
	if (pickers.length)  {
		if (activeClasses===undefined)  activeClasses=[this.classNames.activePicker];
		else if (!(activeClasses instanceof Array))  activeClasses=[activeClasses];
		if (typeof flag !== 'boolean')  flag=true;
		if (pickerName  &&  this.picker_select)  this.picker_select.setSelected(pickerName);
		for (const pckr of pickers)  {
			let chosen= (pckr.id==="") || (!this.picker_select) || this.picker_select.isChosenPicker(pckr);
			UniDOM.useClass(pckr, this.classNames.selectedPicker, chosen);
			chosen=flag && chosen;
			for (const cn of activeClasses)  {UniDOM.useClass(pckr, cn, chosen);}
			UniDOM.generateEvent(pckr, 'pickerStateChange', {bubbles:true}, {pickerStateFlag: chosen, classes: activeClasses});  }  }  }



Picker.prototype.pick=function pick(chosen)  {
	chosen=this.applyFilters(...arguments);
	if (chosen===false)  return;
	const currentTarget= this.currentTarget;
	var isAdditive;
	if (currentTarget.hasAttribute?.('additive'))  {
		isAdditive=currentTarget.getAttribute('additive') || true;
		if (Boolean.eval(isAdditive, true)===false)  isAdditive=false;  }
	else  isAdditive=this.targetIsAdditive;
	switch (currentTarget.nodeName)  {
		case '#text':  if (isAdditive)  currentTarget.data+=chosen;  else  currentTarget.data=chosen;
		break;
		case 'SELECT':
			if (isAdditive  ||  currentTarget.options.length<1)
				currentTarget.add(chosen, chosen, false, true);
			else  {
				currentTarget.options[currentTarget.selectedIndex||0].value=chosen;
				currentTarget.options[currentTarget.selectedIndex||0].text=chosen;  }
		break;
		case 'INPUT':
			const dl=document.getElementById(currentTarget.list);
			if (dl)  {
				if (isAdditive  ||  dl.options.length<1)
					dl.options[dl.options.length]=chosen;
				else  {
					dl.options[currentTarget.selectedIndex||0].value=chosen;
					dl.options[currentTarget.selectedIndex||0].text=chosen;  }  }
		case 'TEXTAREA':
			if (isAdditive)  {
				if (isAdditive==='end')  currentTarget.value+=chosen;
				else  {
					const
						isFocused= (document.activeElement===currentTarget),
						ss= isFocused ? currentTarget.selectionStart : (('oldSelectionStart' in currentTarget) ? currentTarget.oldSelectionStart : currentTarget.value.length),
						se= isFocused ? currentTarget.selectionEnd   : (('oldSelectionEnd' in currentTarget)   ? currentTarget.oldSelectionEnd   : currentTarget.value.length);
					currentTarget.value= currentTarget.value.substring(0,ss) + chosen + currentTarget.value.substring(se);
					currentTarget.selectionStart= currentTarget.selectionEnd= ss+chosen.length;
					currentTarget.newCursorPosition=ss+chosen.length;  }
				break;  }
		default:
			currentTarget.value=chosen;  }
	if (UniDOM.isElement(currentTarget))  {
		try {UniDOM.generateEvent(currentTarget, 'onchange', {bubbles:true});}
		catch(err) {console.error(err);};
		try {currentTarget.focus();}
		catch(err) {console.error(err);};  }  }



Picker.prototype.applyFilters=function applyFilters(chosen)  {
	for (const filter of this.pickFilters)  {
    if (typeof filter.onPick === 'function')
			arguments[0]=filter.onPick(...arguments);
		else  arguments[0]=filter.apply(this, arguments);  }
	return arguments[0];  }





//You may use this quick utility to register standard event handlers that activate the picker
// when the given <input> element is active (has focus)
//pass in the <input> as the “element”
//if you want the picker to “move” (pop-up, etc) with each <input> registered, include a “PickerContainer” that
// the picker will be inserted into when the given <input> is activated
//  the Element will be a “PickerInstance.dataTarget” when focused
Picker.prototype.registerTargetElement=function registerTargetElement(element, pickerContainer)  {
	// the following two properties are meant to be attached to an <input>, <textarea> etc. (i.e. a “dataTarget”) as event handlers.
	UniDOM.addEventHandler(element, 'onFocus', () => {
		if ('newCursorPosition' in this)  {
			this.selectionStart=this.selectionEnd=this.newCursorPosition;
			delete this.newCursorPosition;  }
		this.setActivePickerState(true, element);});
	UniDOM.addEventHandler(element, 'tabIn', () => {
		element.scrollIntoView({behavior:'smooth', block:'nearest'});
		element.focus();  });
	UniDOM.addEventHandler(element, 'onBlur', event => {
		//here we keep track of the cursor location so we can add text if the input looses focus when we pick
		element.oldSelectionStart=element.selectionStart;
		element.oldSelectionEnd=  element.selectionEnd;
		delete this.newCursorPosition;
		if (!this.isInterfaceControl(event.relatedTarget))  this.setActivePickerState(false, element);  });
	UniDOM.addEventHandler(element, 'onKeyDown', event => {
		goDeep.className=this.classNames.picker;   // see private members below
		goDeep.picker_select=this.picker_select;  //
		var tabTo;
		if ((this.panelTabKey.sniff(event)  ||  (event.ctrlKey  &&  event.key==='Tab'))
		&&  (tabTo=( this.picker_select
							|| this.panels.filter(outDisabled).reverse().getElements(isTabStop, goDeep)[0] )))  {
			event.preventDefault();
			UniDOM.generateEvent(tabTo, 'tabIn', {bubbles:true}, {relatedTarget: event.target, tabbedFrom: event.target});  }  });
	// note the element may have a “data-picker-container” attribute as well!
	if (typeof pickerContainer === 'string'  // ←id of the element; ↓ or the element itself
	||  UniDOM.isElement(pickerContainer))  element.pickerContainer=pickerContainer;
	this.registeredTargets.push(element);  }


Picker.prototype.isInterfaceControl=function(elmnt)  {
	//a previous event may have removed this element from the DOM
	if (elmnt?.parentNode  &&  UniDOM.isElement(elmnt))  {
		if (this.interfaceControls?.includes(elmnt))  return true;
		for (const panel of this.panels)  {if (UniDOM.hasAncestor(elmnt, panel))  return true;}  }
	return false;  }


//private members for registering “inputs” (TargetElements & InterfaceControls) - to be used with UniDOM’s DOM-crawling methods
function isInput(e)  {
	return ( e.type!=='hidden'
				 &&  (e.nodeName==='INPUT' || e.nodeName==='SELECT' || e.nodeName==='TEXTAREA' || e.nodeName==='BUTTON') );  }
function isTabStop(e)  {
	var ti,
			isI=( isInput(e)
					 &&  !e.disabled
					 &&  (!(ti=e.getAttribute('tabIndex')) || parseInt(ti)>=0) );
	if (isI)  goDeep.doContinue=false;
	return isI;  }
function goDeep(e)  {
	return ( //avoids inputs on non-active pickers
	goDeep.doContinue  // note that UniDOM’s DOM-crawling methods use this property to completely terminate further searching
	&&  (!e.disabled)  // see UniDOM.disable()
	&&  ( e.id==""  ||  !goDeep.picker_select  ||  !UniDOM.has$Class(e, goDeep.className)
		||  goDeep.picker_select.isChosenPicker(e) ) );  }
function outDisabled(e) {return !e.disabled}

//The functionality of the above private members is exposed here for your convenience as static functions of the Picker Class,
// but changing these Picker properties will not effect the Picker's performance.
Picker.isInput=isInput;
Picker.isTabStop=isTabStop;
Picker.goDeep=goDeep;

Picker.is_UserData_InputType=is_UserData_InputType;
function is_UserData_InputType(e)  { return (
				e.type!=='hidden'
		&&  (e.nodeName==='SELECT'
			|| e.nodeName==='TEXTAREA'
			|| (e.nodeName==='INPUT' && inpTypes.includes(e.type))
/*
 *   this is a hang-up: with it, browser(s) now fail to keep focus on the target due to event.preventDefault();
 *   without it, you can not focus an <input> by clicking on its label
			|| (e.nodeName==='LABEL' && has_UserData_InputType(e))
 */
			) );  }
function has_UserData_InputType(e)  {
	function hasit(c) {const isit=is_UserData_InputType(c);  if (isit) UniDOM.alwaysTrue.doContinue=false;  return isit;}
	return UniDOM.getElements(e, hasit, UniDOM.alwaysTrue)[0];  }

const inpTypes=[
		'text', 'search', 'tel', 'url', 'email', 'password', 'datetime', 'datetime-local',
		 'date', 'month', 'week', 'time', 'number', 'color', 'file', 'range' ];
Object.freeze(inpTypes);
Object.defineProperty(is_UserData_InputType, 'inpTypes', {value: inpTypes, enumerable:true});


/* If you want to use an input or select that requires “focus” as an interface control for your picker (i.e., your
		picker may be dynamic, and the user may control this dynamism using HTML form elements either integrated into
		the picker HTML itself or elsewhere in the document), this will take focus away from the target input (or whatever you use).
		Without registering your interface control, the Picker Class will loose track of whether to show the picker, etc.
	 So for every <input /> (type = text, number, file, etc: any that requires or accepts keyboard input)
		and every <textbox> and every <select> that is an interface control for your picker, use the method below.
	 Checkboxes, radio buttons, <input type='range' /> etc. do not require focus,
		and do not strictly need to be registered.
		However, to give them full keyboard access through use of the TAB key,
		they should all be registered with this function.

	 Since the event handlers within alter normal “tab key” functioning, complete tab-control is included.
	 This feature is especially handy with multiple panels that may or not be shown,
	 or with a mainPanel (etc.) that “floats” to multiple different dataTargets’ HTML while another subpanel remains stationary.
	 Trying to manage “tabIndexes” under these conditions is hazardous at best.
	 Using all the Picker methods as prescribed yields the following default user-interface functionality:
	 (note an input is “active” unless it is within a “picker” that is not selected as active)
== TAB | backTAB → from dataTarget  → follows normal HTML DOM form
== ctrlTAB       → from dataTarget  → to the picker_select (if it exists) or to the first active input on the topmost panel
== TAB | backTAB → from interfaceControl  → follows the normal HTML DOM form except:
																				•the first interfaceControl on a panel backTABs to the dataTarget
																				•the last interfaceControl on a panel TABs to the dataTarget
== ctrlTAB       → from interfaceControl  → to the first active input on the second-from-topmost panel (and the current-topmost panel is sent to the bottom)
== ctrlbackTAB   → from interfaceControl  → to the first active input on the bottom panel

	The “actions” object passed in is optional, and may contain the following relevant functions / properties / flags:


	enterKeyed:  «function» enhance the default action of the enter key, or prevent the default Picker action by returning true.
	tabbedOut:   «function» enhance the default action of the tab key, or prevent the default Picker action by returning true.
	tabTo:       «string» ‖ «DOM_Element» tab key sends focus here.
								«string» may be a “DOM Element id” or a JavaScript expression that evaluates to a “DOM ELement.”
								This may be overridden or replaced using an HTML attribute “tabTo” in the interface-control element
								with values similar to «string».
	backTabTo:   «string» ‖ «DOM_Element» shift-tab key sends focus here.
								«string» may be a “DOM Element id” or a JavaScript expression that evaluates to a “DOM ELement.”
								This may be overridden or replaced using an HTML attribute “backTabTo” in the interface-control element
								with values similar to «string».
	tabToTarget: «Boolean» tab key returns focus to the target (input) element, instead of the default of passing focus
								to the “next” focus-able form element.
								This may be overridden or replaced using an HTML attribute “tabToTarget” in the interface-control element
								with values of 'true' or 'false'.
	backtabToTarget: «Boolean» shift-tab key returns focus to the target (input) element, instead of the default of passing focus
								to the “previous” focus-able form element.
								This may be overridden or replaced using an HTML attribute “backtabToTarget” in the interface-control element
								with values of 'true' or 'false'.
	onchange:    «function» enhance the default action of the Picker onchange method, or prevent the default Picker action by returning true.
 */
// If you ever want to manually focus an InterfaceControl, you should generate a “tabin” event on it.
// NOTE do NOT use this method for Interface-Elements in a registered Picker-Panel, only “lone-wolf” elements
Picker.prototype.registerInterfaceControl=function registerInterfaceControl(element, actions)  {
	if (this.interfaceControls instanceof Array)  {
		if (this.interfaceControls.includes(element))  return;  }  //prevent multiple-registration
	else  this.interfaceControls=new UniDOM.ElementArray;
	this.interfaceControls.push(element);
	const isTarget=Boolean.eval(element.getAttribute(this.ATTRIBUTE_NAMES.interfaceTarget), element.hasAttribute(this.ATTRIBUTE_NAMES.interfaceTarget));
	if (isTarget  ||  (actions?.interfaceTarget  &&  isTarget!==false))  {
		if (!(this.interfaceTargets instanceof Array))  this.interfaceTargets=new UniDOM.ElementArray;
		this.interfaceTargets.push(element)  }

	const isUserdataInputType=is_UserData_InputType(element);  //note that “Data” is capitaliized in the Function name, not the result’s name

	registerInterfaces.call(this, element, actions, isUserdataInputType);  }



//  private METHOD of a Picker-instance
function registerInterfaces(element, actions, isUserdataInputType)  {  //element may be an INPUT (etc.) or a whole panel
	const PickerInstance=this;
	var tabbedOut, enterKeyed, selectPan, escaped;

	if (isUserdataInputType)  {  // these can be focused with the mouse or the TAB key
		UniDOM.addEventHandler(element, 'onFocus',  focusOnInterfaceControl);
		UniDOM.addEventHandler(element, 'tabIn', tabIntoUserdataInputType);  }
	else if (isInput(element))  // what is left can only be focused with the TAB key (checkbox | radio)
		UniDOM.addEventHandler(element, 'tabIn', tabIntoInterfaceControl);
	else  {  // these are panels and do not themselves focus
		UniDOM.addEventHandler(element, 'tabIn', function tabIntoPanel(event)  {
			if (is_UserData_InputType(event.target))  tabIntoUserdataInputType(event);
			else tabIntoInterfaceControl(event);  });
		UniDOM.addEventHandler(element, 'focusIn', function focusIn_InPanel(event)  {
			if (is_UserData_InputType(event.target))  focusOnInterfaceControl(event);  });  }

	UniDOM.addEventHandler(element, 'change', function refocusFileInput()  {
		if (event.target.type==='file')  {
			PickerInstance.setActivePickerState(true);
			event.target.focus();  }  });

// If you ever want to manually focus an InterfaceControl, you should generate a “tabin” event on it
// unless it is guaranteed to already be displayed to the user.
	function focusOnInterfaceControl(event)  {
		const
			flag=Boolean.eval(event.target.getAttribute(PickerInstance.ATTRIBUTE_NAMES.interfaceTarget, element.hasAttribute(PickerInstance.ATTRIBUTE_NAMES.interfaceTarget))),
			thisPanel=UniDOM.getAncestorBy$Class(event.target, PickerInstance.classNames.pickerPanel);
		PickerInstance.setActiveInterfaceState(true, event.target, (flag || (actions?.interfaceTarget && flag!==false)));
		if (thisPanel)  PickerInstance.setTopPanel(thisPanel);
		tabbedOut= enterKeyed= selectPan= escaped= false;  }

	function tabIntoUserdataInputType(event) {
		//an element must be displayed to receive focus, so we get a bit redundant
		const
			flag=Boolean.eval(event.target.getAttribute(PickerInstance.ATTRIBUTE_NAMES.interfaceTarget), element.hasAttribute(PickerInstance.ATTRIBUTE_NAMES.interfaceTarget)),
			thisPanel=UniDOM.getAncestorBy$Class(event.target, PickerInstance.classNames.pickerPanel);
		PickerInstance.setActiveInterfaceState(true, event.target, (flag || (actions?.interfaceTarget && flag!==false)));
		if (thisPanel)  PickerInstance.setTopPanel(thisPanel, event.rotatePanels);
		setTimeout(() => {
				event.target.scrollIntoView({behavior:'smooth', block:'nearest'});
				event.target.focus();},
			0);  }

	function tabIntoInterfaceControl(event) {
		PickerInstance.setActiveInterfaceState(true, event.target);
		const
			thisPanel=UniDOM.getAncestorBy$Class(event.target, PickerInstance.classNames.pickerPanel);
		if (thisPanel) PickerInstance.setTopPanel(thisPanel, event.rotatePanels);
		tabbedOut= enterKeyed= selectPan= escaped= false;
		setTimeout(() => {
				event.target.scrollIntoView({behavior:'smooth', block:'nearest'});
				event.target.focus();},
			0);  }


	UniDOM.addEventHandler(element, 'onkeydown', function keyDownOnInterfaceControl(event)  {
		tabbedOut=(event.key==='Tab'  ||  PickerInstance.panelTabKey.sniff(event)  ||  PickerInstance.panelBacktabKey.sniff(event));
		enterKeyed=(event.key==='Enter');
		selectPan=(event.target.nodeName==='SELECT'  &&  (event.key==='ArrowUp' || event.key==='ArrowDown'));
		escaped=(event.key==='Escape');
		if (tabbedOut)  {
			if (actions?.onTabOut?.(event))  return;
			let
				tabTo, indx,
				shifted=(event.key==='Tab' && event.shiftKey)  ||  PickerInstance.panelBacktabKey.sniff(event);
			function getAdjacentPanelTabStop()  {
				return (
					( tabTo= PickerInstance.panels.ctrlTabTo  // this property is entirely outer-application controlled; it may be a tabStop or a UniDOM.ElementArray of panel(s) with a tabStop
										||  ( (indx=PickerInstance.panels.indexOf(UniDOM.getAncestorBy$Class(event.target, PickerInstance.classNames.pickerPanel))),
													PickerInstance.panels.slice(indx+1).concat(PickerInstance.panels.slice(0, indx)) ) )
					&&  ( isTabStop(tabTo)  //  ← see private members above  ↓                         ↓          ↓
						|| (tabTo=(shifted ? tabTo : tabTo.reverse()).filter(outDisabled).getElements(isTabStop, goDeep)[0])
						|| (isTabStop(PickerInstance.dataTarget)  &&  (tabTo=PickerInstance.dataTarget))  ) );  }
			event.preventDefault();
			goDeep.className=PickerInstance.classNames.picker;
			goDeep.picker_select=PickerInstance.picker_select;
			if (event.ctrlKey  //note browsers use CTRL-TAB to switch between open browser tabs - this key-combo is fully blocked to scripts and should be - too easy to spoof “PayPal” if your script opens paypal.com in a new window for a “payment” …
/**/
			&&  getAdjacentPanelTabStop())  {
				UniDOM.generateEvent(tabTo, 'tabIn', {bubbles:true}, {relatedTarget: event.target, tabbedFrom: event.target, rotatePanels: (shifted ? false : indx )});
				UniDOM.generateEvent(event.target, 'tabOut', {bubbles:true}, {relatedTarget: tabTo, tabTo: tabTo});
				return;  }
			if ((!shifted
					&&  (tabTo=(event.target.getAttribute(PickerInstance.ATTRIBUTE_NAMES.tabTo)  ||  event.target[PickerInstance.ATTRIBUTE_NAMES.tabTo]  ||  actions?.tabTo)))
			||  (shifted
					&&  (tabTo=(event.target.getAttribute(PickerInstance.ATTRIBUTE_NAMES.backtabTo)  ||  event.target[PickerInstance.ATTRIBUTE_NAMES.backtabTo]  ||  actions?.backtabTo))))
				try {
					let rotated;
					if (typeof tabTo === 'string')  {
						if (tabTo==='{none}')  return;
						switch (tabTo.substring(0,1))  {
							case '#': tabTo=event.target.ownerDocument.getElementById(tabTo.substring(1));
							break;
							case '@': switch (tabTo.substring(1))  {
								case 'next-panel': rotated=shifted=false;  getAdjacentPanelTabStop();
								break;
								case 'previous-panel': shifted=true;  getAdjacentPanelTabStop();  rotated=indx;
								break;
								case 'adjacent-panel': getAdjacentPanelTabStop();
								break;
								case 'target': tabTo= PickerInstance.dataTarget;
								break;
								default: tabTo=null;  }
							break;
							default: tabTo=(new Function('event', 'PickerInstance', 'actions', 'return ('+tabTo+');')).call(event.target, event, PickerInstance, actions);  }  }
/*
						tabTo=( event.target.ownerDocument.getElementById(tabTo)
								 || (new Function('event', 'actions', 'return ('+tabTo+');')).call(event.target, event, PickerInstance, actions) );  }
*/
					else if (typeof tabTo == 'function')  tabTo=tabTo(event, PickerInstance, actions);
					if (UniDOM.isElement(tabTo))  {
						UniDOM.generateEvent(tabTo, 'tabIn', {bubbles:true}, {relatedTarget: event.target, tabbedFrom: event.target, rotatePanels:rotated});
						UniDOM.generateEvent(event.target, 'tabOut', {bubbles:true}, {relatedTarget: tabTo, tabbedTo: tabTo});
						return;  }  }
				catch(e) {console.error("Custom tab-expression or tab-event failed for:",event.target,"\n in Picker’s “keyDownOnInterfaceControl” handler:",e);};
			const
				tabToTarget=Boolean.eval(event.target.getAttribute(PickerInstance.ATTRIBUTE_NAMES.tabToTarget), event.target.hasAttribute(PickerInstance.ATTRIBUTE_NAMES.tabToTarget)),
				backtabToTarget=Boolean.eval(event.target.getAttribute(PickerInstance.ATTRIBUTE_NAMES.backtabToTarget), event.target.hasAttribute(PickerInstance.ATTRIBUTE_NAMES.backtabToTarget));
			if ((!shifted  &&  (tabToTarget  ||  (actions?.tabToTarget  &&  tabToTarget!==false)))
			||  (shifted  &&  (backtabToTarget  ||  (actions?.backtabToTarget  &&  backtabToTarget!==false))))  {
				try {
					const target=PickerInstance.dataTarget;
					if (target)  {
						UniDOM.generateEvent(target, 'tabIn', {bubbles:true}, {relatedTarget:event.target, tabbedFrom: event.target});
						UniDOM.generateEvent(event.target, 'tabOut', {bubbles:true}, {relatedTarget:target, tabbedTo: target});  }  }
				catch(e) {}
				finally {return;}  }
			if (tabTo=( shifted ? UniDOM.getElders(event.target, isTabStop, goDeep)[0] : UniDOM.getJuniors(event.target, isTabStop, goDeep)[0]))  {
				UniDOM.generateEvent(tabTo, 'tabIn', {bubbles:true}, {relatedTarget: event.target, tabbedFrom: event.target});
				UniDOM.generateEvent(event.target, 'tabOut', {bubbles:true}, {relatedTarget: tabTo, tabbedTo: tabTo});  }  }
		if (enterKeyed)  {
			enterKeyPressCount++;  clearTimeout(enterKeyPressRepeatTimeout);
			enterKeyPressRepeatTimeout=setTimeout(function() {enterKeyPressCount=0;}, SoftMoon.keyPressRepeatTimeoutDelay);
			if (actions?.onEnterKeyed?.(event))  return;
			if (event.target.nodeName!=='SELECT'  &&  event.target.nodeName!=='TEXTAREA'  &&  event.target.nodeName!=='BUTTON'
			&&  (event.target.nodeName!=='INPUT'
					||  ( event.target.type!=='button'
						&&  event.target.type!=='checkbox'
						&&  event.target.type!=='radio'
						&&  event.target.type!=='range' )) )  {
				event.preventDefault();
				//note below we want to allow other user-added event-handlers to be executed as well…
				UniDOM.generateEvent(event.target, 'change', {bubbles:true}, {enterKeyed: true, keyedCount: enterKeyPressCount});
				enterKeyed=false;
				if ( event.target.hasAttribute('keep-focus') ?
								Boolean.eval(event.target.getAttribute('keep-focus'), true)
							: PickerInstance.doKeepInterfaceFocus )
					{;} //event.target.focus();
				else  try {PickerInstance.dataTarget?.focus?.();}catch(e){}  }
			else {
				if (event.target.type==='checkbox'  ||  event.target.type==='radio')  {event.target.checked=!event.target.checked;  event.preventDefault();}
				else if (event.target.nodeName==='BUTTON')  {
					UniDOM.generateEvent(event.target, 'buttonpress',
						{bubbles:true, detail: enterKeyPressCount}, {shiftKey: event.shiftKey, ctrlKey: event.ctrlKey, altKey: event.altKey});
					event.preventDefault();  }
				UniDOM.generateEvent(event.target, 'change',
						{bubbles: true}, {enterKeyed: true, keyedCount: enterKeyPressCount, shiftKey: event.shiftKey, ctrlKey: event.ctrlKey, altKey: event.altKey});
				}  }
		if (escaped)  {
			if (actions?.onEscape?.(event))  return;
			const tabTo=PickerInstance.dataTarget;
			UniDOM.generateEvent(event.target, 'tabout', {bubbles:true}, {tabbedTo: tabTo} );
			try {tabTo?.focus?.();}catch(e){}  }  });


	var enterKeyPressCount=0, enterKeyPressRepeatTimeout;

/*
	if (isInput(element))
		UniDOM.addEventHandler(element, 'onBlur', focusOutOfInterfaceControl);
	else
		UniDOM.addEventHandler(element, 'focusOut', function(event)  {
			if (isInput(event.target))  focusOutOfInterfaceControl(event);  });
*/
	UniDOM.addEventHandler(element, 'focusOut', focusOutOfInterfaceControl);


	function focusOutOfInterfaceControl(event)  {
		if (enterKeyed)  {
			enterKeyed=false;
			if (Boolean.eval(event.target.getAttribute('keep-focus'), true))  {event.target.focus();  return;}  }
		//PickerInstance.setActiveInterfaceState(false, event.target);
		if (isInput(event.target))  PickerInstance.setActiveInterfaceState(false, event.target);
		if (!tabbedOut  //we can only TAB to other related InterfaceControls
		&&  (!event.relatedTarget  //but we can click anywhere…
			||  ( event.relatedTarget!==PickerInstance.dataTarget
				&&  event.relatedTarget!==PickerInstance.masterTarget ))
		&&  !PickerInstance.isInterfaceControl(event.relatedTarget))
			PickerInstance.setActivePickerState(false);  }


} // close  registerInterfaces()



Picker.prototype.registerInterfacePanel=function(panel, actions)  {
	UniDOM.addClass(panel, this.classNames.pickerPanel);
	this.panels.unshift(panel);
	this.setTopPanel();
	const
		PickerInstance=this,
		pickers=UniDOM.getElementsBy$Class(panel, this.classNames.picker);

	for (const pckr of pickers)  {this.registerPicker(pckr);}

	UniDOM.addEventHandler(panel, 'onClick', clickOnInterfacePanel);
	UniDOM.addEventHandler(panel, 'onMouseDown', mousedownOnInterfacePanel);

	function clickOnInterfacePanel(event)  {
		if (is_UserData_InputType(event.target))  return;
		if (PickerInstance.currentTarget
		&&  (!document.hasFocus()
				||  (  (!PickerInstance.isInterfaceControl(event.target)  ||  !is_UserData_InputType(event.target))
						&&  !PickerInstance.registeredTargets.includes(document.activeElement))))
			UniDOM.generateEvent(PickerInstance.currentTarget, 'tabIn', {bubbles:true});
		if (!PickerInstance.interfaceTarget
		||  !event.target.parentNode  // a previous event-handler may have removed this element from the DOM
		||  !UniDOM.getAncestorBy$Class(event.target, PickerInstance.classNames.picker))
			PickerInstance.setTopPanel(panel);  }

	function mousedownOnInterfacePanel(event)  {
		if (!is_UserData_InputType(event.target))  event.preventDefault();	}

	registerInterfaces.call(this, panel, actions);  }


Picker.prototype.registerPicker=function (picker)  {
	this.pickers.push(picker);  }


}  // close private namespace for Picker

// using relaxed rules; perhaps you want to prefix "data-" to each
SoftMoon.WebWare.Picker.ATTRIBUTE_NAMES={
	interfaceTarget: 'interfaceTarget',
	tabTo: 'tabTo',
	backtabTo: 'backtabTo',
	tabToTarget: 'tabToTarget',
	backtabToTarget: 'backtabToTarget' }
